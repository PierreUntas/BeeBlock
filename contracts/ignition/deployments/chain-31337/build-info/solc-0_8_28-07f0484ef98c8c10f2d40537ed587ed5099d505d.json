{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-07f0484ef98c8c10f2d40537ed587ed5099d505d",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/HoneyTraceStorage.sol": "project/contracts/HoneyTraceStorage.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/"
      ]
    },
    "sources": {
      "npm/@openzeppelin/contracts@5.4.0/access/Ownable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/Context.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/cryptography/Hashes.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/cryptography/Hashes.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library of standard hash functions.\n *\n * _Available since v5.1._\n */\nlibrary Hashes {\n    /**\n     * @dev Commutative Keccak256 hash of a sorted pair of bytes32. Frequently used when working with merkle proofs.\n     *\n     * NOTE: Equivalent to the `standardNodeHash` in our https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\n     */\n    function commutativeKeccak256(bytes32 a, bytes32 b) internal pure returns (bytes32) {\n        return a < b ? efficientKeccak256(a, b) : efficientKeccak256(b, a);\n    }\n\n    /**\n     * @dev Implementation of keccak256(abi.encode(a, b)) that doesn't allocate or expand memory.\n     */\n    function efficientKeccak256(bytes32 a, bytes32 b) internal pure returns (bytes32 value) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/cryptography/MerkleProof.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/cryptography/MerkleProof.sol)\n// This file was procedurally generated from scripts/generate/templates/MerkleProof.js.\n\npragma solidity ^0.8.20;\n\nimport {Hashes} from \"./Hashes.sol\";\n\n/**\n * @dev These functions deal with verification of Merkle Tree proofs.\n *\n * The tree and the proofs can be generated using our\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\n * You will find a quickstart guide in the readme.\n *\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\n * hashing, or use a hash function other than keccak256 for hashing leaves.\n * This is because the concatenation of a sorted pair of internal nodes in\n * the Merkle tree could be reinterpreted as a leaf value.\n * OpenZeppelin's JavaScript library generates Merkle trees that are safe\n * against this attack out of the box.\n *\n * IMPORTANT: Consider memory side-effects when using custom hashing functions\n * that access memory in an unsafe way.\n *\n * NOTE: This library supports proof verification for merkle trees built using\n * custom _commutative_ hashing functions (i.e. `H(a, b) == H(b, a)`). Proving\n * leaf inclusion in trees built using non-commutative hashing functions requires\n * additional logic that is not supported by this library.\n */\nlibrary MerkleProof {\n    /**\n     *@dev The multiproof provided is not valid.\n     */\n    error MerkleProofInvalidMultiproof();\n\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     *\n     * This version handles proofs in memory with the default hashing function.\n     */\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leaves & pre-images are assumed to be sorted.\n     *\n     * This version handles proofs in memory with the default hashing function.\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = Hashes.commutativeKeccak256(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     *\n     * This version handles proofs in memory with a custom hashing function.\n     */\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf,\n        function(bytes32, bytes32) view returns (bytes32) hasher\n    ) internal view returns (bool) {\n        return processProof(proof, leaf, hasher) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leaves & pre-images are assumed to be sorted.\n     *\n     * This version handles proofs in memory with a custom hashing function.\n     */\n    function processProof(\n        bytes32[] memory proof,\n        bytes32 leaf,\n        function(bytes32, bytes32) view returns (bytes32) hasher\n    ) internal view returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = hasher(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     *\n     * This version handles proofs in calldata with the default hashing function.\n     */\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leaves & pre-images are assumed to be sorted.\n     *\n     * This version handles proofs in calldata with the default hashing function.\n     */\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = Hashes.commutativeKeccak256(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     *\n     * This version handles proofs in calldata with a custom hashing function.\n     */\n    function verifyCalldata(\n        bytes32[] calldata proof,\n        bytes32 root,\n        bytes32 leaf,\n        function(bytes32, bytes32) view returns (bytes32) hasher\n    ) internal view returns (bool) {\n        return processProofCalldata(proof, leaf, hasher) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leaves & pre-images are assumed to be sorted.\n     *\n     * This version handles proofs in calldata with a custom hashing function.\n     */\n    function processProofCalldata(\n        bytes32[] calldata proof,\n        bytes32 leaf,\n        function(bytes32, bytes32) view returns (bytes32) hasher\n    ) internal view returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = hasher(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a Merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * This version handles multiproofs in memory with the default hashing function.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * NOTE: Consider the case where `root == proof[0] && leaves.length == 0` as it will return `true`.\n     * The `leaves` must be validated independently. See {processMultiProof}.\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * This version handles multiproofs in memory with the default hashing function.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     *\n     * NOTE: The _empty set_ (i.e. the case where `proof.length == 1 && leaves.length == 0`) is considered a no-op,\n     * and therefore a valid multiproof (i.e. it returns `proof[0]`). Consider disallowing this case if you're not\n     * validating the leaves elsewhere.\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofFlagsLen = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proof.length != proofFlagsLen + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](proofFlagsLen);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < proofFlagsLen; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = Hashes.commutativeKeccak256(a, b);\n        }\n\n        if (proofFlagsLen > 0) {\n            if (proofPos != proof.length) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[proofFlagsLen - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a Merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * This version handles multiproofs in memory with a custom hashing function.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * NOTE: Consider the case where `root == proof[0] && leaves.length == 0` as it will return `true`.\n     * The `leaves` must be validated independently. See {processMultiProof}.\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves,\n        function(bytes32, bytes32) view returns (bytes32) hasher\n    ) internal view returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves, hasher) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * This version handles multiproofs in memory with a custom hashing function.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     *\n     * NOTE: The _empty set_ (i.e. the case where `proof.length == 1 && leaves.length == 0`) is considered a no-op,\n     * and therefore a valid multiproof (i.e. it returns `proof[0]`). Consider disallowing this case if you're not\n     * validating the leaves elsewhere.\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves,\n        function(bytes32, bytes32) view returns (bytes32) hasher\n    ) internal view returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofFlagsLen = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proof.length != proofFlagsLen + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](proofFlagsLen);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < proofFlagsLen; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = hasher(a, b);\n        }\n\n        if (proofFlagsLen > 0) {\n            if (proofPos != proof.length) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[proofFlagsLen - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a Merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * This version handles multiproofs in calldata with the default hashing function.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * NOTE: Consider the case where `root == proof[0] && leaves.length == 0` as it will return `true`.\n     * The `leaves` must be validated independently. See {processMultiProofCalldata}.\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * This version handles multiproofs in calldata with the default hashing function.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     *\n     * NOTE: The _empty set_ (i.e. the case where `proof.length == 1 && leaves.length == 0`) is considered a no-op,\n     * and therefore a valid multiproof (i.e. it returns `proof[0]`). Consider disallowing this case if you're not\n     * validating the leaves elsewhere.\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofFlagsLen = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proof.length != proofFlagsLen + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](proofFlagsLen);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < proofFlagsLen; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = Hashes.commutativeKeccak256(a, b);\n        }\n\n        if (proofFlagsLen > 0) {\n            if (proofPos != proof.length) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[proofFlagsLen - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a Merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * This version handles multiproofs in calldata with a custom hashing function.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * NOTE: Consider the case where `root == proof[0] && leaves.length == 0` as it will return `true`.\n     * The `leaves` must be validated independently. See {processMultiProofCalldata}.\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves,\n        function(bytes32, bytes32) view returns (bytes32) hasher\n    ) internal view returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves, hasher) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * This version handles multiproofs in calldata with a custom hashing function.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     *\n     * NOTE: The _empty set_ (i.e. the case where `proof.length == 1 && leaves.length == 0`) is considered a no-op,\n     * and therefore a valid multiproof (i.e. it returns `proof[0]`). Consider disallowing this case if you're not\n     * validating the leaves elsewhere.\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves,\n        function(bytes32, bytes32) view returns (bytes32) hasher\n    ) internal view returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofFlagsLen = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proof.length != proofFlagsLen + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](proofFlagsLen);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < proofFlagsLen; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = hasher(a, b);\n        }\n\n        if (proofFlagsLen > 0) {\n            if (proofPos != proof.length) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[proofFlagsLen - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/ReentrancyGuard.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
      },
      "project/contracts/HoneyTraceStorage.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\n/**\n * @title IHoneyTokenization\n * @dev Interface for the HoneyTokenization contract\n */\ninterface IHoneyTokenization {\n    function mintHoneyBatch(address producer, uint256 amount, string memory uri) external returns (uint256);\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes memory data) external;\n    function tokenProducer(uint256 tokenId) external view returns (address);\n}\n\n/**\n * @title HoneyTraceStorage\n * @dev Main contract for honey traceability system using Merkle Tree for secure token distribution\n * @notice This contract manages producers, honey batches, and token claims using cryptographic proofs\n *\n * The contract implements a three-tier authorization system:\n * 1. Owner can add admins\n * 2. Admins can authorize producers\n * 3. Authorized producers can create honey batches\n *\n * Token distribution uses Merkle Tree proofs for gas-efficient and secure claiming.\n */\ncontract HoneyTraceStorage is Ownable, ReentrancyGuard {\n\n    // ============ CONSTANTS ============\n\n    /// @dev Maximum number of tokens that can be minted in a single batch\n    uint256 public constant MAX_BATCH_SIZE = 100_000;\n\n    /// @dev Maximum number of comments a user can add per batch\n    uint256 public constant MAX_COMMENTS_PER_USER = 10;\n\n    // ============ STRUCTS ============\n\n    /**\n     * @dev Structure representing a honey producer\n     * @param id Ethereum address of the producer\n     * @param authorized Whether the producer is authorized to create batches\n     * @param name Business name of the producer\n     * @param location Physical location of production\n     * @param companyRegisterNumber Official business registration number\n     * @param metadata Additional information in JSON format (certifications, etc.)\n     */\n    struct Producer {\n        address id;\n        bool authorized;\n        string name;\n        string location;\n        string companyRegisterNumber;\n        string metadata;\n    }\n\n    /**\n     * @dev Structure representing a honey batch\n     * @param id Unique identifier for the batch (same as ERC1155 token ID)\n     * @param honeyType Type of honey (e.g., \"Acacia\", \"Lavender\")\n     * @param metadata Batch-specific information (origin, harvest date, etc.)\n     * @param merkleRoot Root hash of the Merkle Tree containing all secret keys for this batch\n     */\n    struct HoneyBatch {\n        uint id;\n        string honeyType;\n        string metadata;\n        bytes32 merkleRoot;\n    }\n\n    /**\n     * @dev Structure representing a consumer comment/review\n     * @param consumer Address of the consumer who left the comment\n     * @param honeyBatchId ID of the batch being reviewed\n     * @param rating Numerical rating (0-5)\n     * @param metadata Comment text and additional information in JSON format\n     */\n    struct Comment {\n        address consumer;\n        uint honeyBatchId;\n        uint8 rating;\n        string metadata;\n    }\n\n    // ============ STATE VARIABLES ============\n\n    /// @dev Mapping from producer address to their information\n    mapping(address => Producer) producers;\n\n    /// @dev Mapping from batch ID to batch information\n    mapping(uint => HoneyBatch) honeyBatches;\n\n    /// @dev Mapping from batch ID to array of comments\n    mapping(uint => Comment[]) honeyBatchesComments;\n\n    /// @dev Mapping to track admin addresses\n    mapping(address => bool) public admins;\n\n    /// @dev Reference to the HoneyTokenization contract\n    IHoneyTokenization public honeyTokenization;\n\n    /**\n     * @dev Nested mapping to track claimed keys\n     * First key: batch ID\n     * Second key: hash of the secret key\n     * Value: whether this key has been claimed\n     *\n     * This prevents double-claiming of the same QR code\n     */\n    mapping(uint256 => mapping(bytes32 => bool)) private claimedKeys;\n\n    /**\n     * @dev Mapping to track number of comments per user per batch\n        * First key: batch ID\n        * Second key: user address\n        * Value: number of comments made by the user for that batch\n     */\n    mapping(uint => mapping(address => uint)) public commentCount;\n\n    // ============ EVENTS ============\n\n    /**\n     * @dev Emitted when a new admin is added\n     * @param newAdmin Address of the newly added admin\n     */\n    event NewAdmin(address indexed newAdmin);\n\n    /**\n     * @dev Emitted when a producer's authorization status changes\n     * @param producer Address of the producer\n     * @param isAuthorized New authorization status\n     */\n    event AuthorizationProducer(address indexed producer, bool isAuthorized);\n\n    /**\n    * @dev Emitted when an admin is removed\n     * @param admin Address of the removed admin\n     */\n    event AdminRemoved(address indexed admin);\n\n    /**\n     * @dev Emitted when a producer registers their information\n     * @param producer Address of the producer\n     */\n    event NewProducer(address indexed producer);\n\n    /**\n     * @dev Emitted when a new honey batch is created\n     * @param producer Address of the producer who created the batch\n     * @param honeyBatchId Unique identifier for the batch\n     */\n    event NewHoneyBatch(address indexed producer, uint indexed honeyBatchId);\n\n    /**\n     * @dev Emitted when a consumer successfully claims a honey token\n     * @param consumer Address of the consumer\n     * @param honeyBatchId ID of the claimed batch\n     * @param keyHash Hash of the secret key used for claiming\n     */\n    event HoneyTokenClaimed(address indexed consumer, uint indexed honeyBatchId, bytes32 keyHash);\n\n    /**\n     * @dev Emitted when a consumer adds a comment to a batch\n     * @param consumer Address of the consumer\n     * @param honeyBatchId ID of the batch being reviewed\n     * @param rating Numerical rating given\n     */\n    event NewComment(address indexed consumer, uint indexed honeyBatchId, uint8 rating);\n\n    // ============ ERRORS ============\n\n    /// @dev Thrown when a non-admin tries to perform an admin-only action\n    error onlyAdminAuthorized();\n\n    /// @dev Thrown when trying to set an authorization status that's already set\n    error authorizationAlreadyApply();\n\n    /// @dev Thrown when an unauthorized producer tries to perform a producer action\n    error producerNotAuthorized();\n\n    /// @dev Thrown when a non-token-holder tries to comment\n    error notAllowedToComment();\n\n    /// @dev Thrown when the Merkle proof verification fails\n    error invalidMerkleProof();\n\n    /// @dev Thrown when trying to claim with an already used secret key\n    error keyAlreadyClaimed();\n\n    /// @dev Thrown when trying to claim but no tokens are left\n    error noTokenLeft();\n\n    /// @dev Thrown when the batch size exceeds the maximum allowed\n    error batchSizeTooLarge();\n\n    /// @dev Thrown when the rating provided is not between 0 and 5\n    error ratingMustBeBetween0And5();\n\n    /// @dev Thrown when the comment limit per user per batch is reached\n    error commentLimitReached();\n\n    /// @dev Thrown when a string parameter length is invalid\n    error InvalidStringLength();\n\n    // ============ MODIFIERS ============\n\n    /**\n     * @dev Modifier to restrict function access to admins only\n     */\n    modifier onlyAdmin() {\n        require(admins[msg.sender], onlyAdminAuthorized());\n        _;\n    }\n\n    /**\n     * @dev Modifier to restrict function access to authorized producers only\n     */\n    modifier onlyAuthorizedProducer() {\n        require(producers[msg.sender].authorized, producerNotAuthorized());\n        _;\n    }\n\n    // ============ CONSTRUCTOR ============\n\n    /**\n     * @dev Initializes the contract with the HoneyTokenization address\n     * @param _honeyTokenizationAddress Address of the deployed HoneyTokenization contract\n     *\n     * The deployer is automatically set as the owner and first admin\n     */\n    constructor(address _honeyTokenizationAddress) Ownable(msg.sender) {\n        honeyTokenization = IHoneyTokenization(_honeyTokenizationAddress);\n        admins[msg.sender] = true;\n    }\n\n    // ============ ADMIN FUNCTIONS ============\n\n    /**\n     * @dev Adds a new admin to the system\n     * @param _newAdmin Address to be granted admin privileges\n     *\n     * Requirements:\n     * - Caller must be the contract owner\n     *\n     * Emits a {NewAdmin} event\n     */\n    function addAdmin(address _newAdmin) external onlyOwner {\n        admins[_newAdmin] = true;\n        emit NewAdmin(_newAdmin);\n    }\n\n    /**\n    * @dev Remove an admin to the system\n     * @param _admin Address to be granted admin privileges\n     *\n     * Requirements:\n     * - Caller must be the contract owner\n     *\n     * Emits a {AdminRemoved} event\n     */\n    function removeAdmin(address _admin) external onlyOwner {\n        admins[_admin] = false;\n        emit AdminRemoved(_admin);\n    }\n\n    /**\n     * @dev Authorizes or revokes authorization for a producer\n     * @param _producer Address of the producer\n     * @param _isAuthorized True to authorize, false to revoke\n     *\n     * Requirements:\n     * - Caller must be an admin\n     * - The authorization status must be different from current status\n     *\n     * Emits an {AuthorizationProducer} event\n     */\n    function authorizeProducer(address _producer, bool _isAuthorized) external onlyAdmin {\n        require(producers[_producer].authorized != _isAuthorized, authorizationAlreadyApply());\n        producers[_producer].authorized = _isAuthorized;\n        emit AuthorizationProducer(_producer, _isAuthorized);\n    }\n\n    // ============ PRODUCER FUNCTIONS ============\n\n    /**\n     * @dev Allows an authorized producer to register or update their information\n     * @param _name Business name\n     * @param _location Physical location\n     * @param _companyRegisterNumber Official registration number\n     * @param _metadata Additional information in JSON format\n     *\n     * Requirements:\n     * - Caller must be an authorized producer\n     *\n     * Emits a {NewProducer} event\n     */\n    function addProducer(\n        string memory _name,\n        string memory _location,\n        string memory _companyRegisterNumber,\n        string memory _metadata\n    ) external onlyAuthorizedProducer {\n        if (bytes(_name).length == 0 || bytes(_name).length > 256) revert InvalidStringLength();\n        if (bytes(_location).length == 0 || bytes(_location).length > 256) revert InvalidStringLength();\n        if (bytes(_companyRegisterNumber).length == 0 || bytes(_companyRegisterNumber).length > 64) revert InvalidStringLength();\n        if (bytes(_metadata).length > 1024) revert InvalidStringLength();\n\n        Producer storage producer = producers[msg.sender];\n        producer.name = _name;\n        producer.location = _location;\n        producer.companyRegisterNumber = _companyRegisterNumber;\n        producer.metadata = _metadata;\n\n        emit NewProducer(msg.sender);\n    }\n\n    /**\n     * @dev Creates a new honey batch with Merkle Tree root for secure distribution\n     * @param _honeyType Type of honey (e.g., \"Acacia\", \"Lavender\")\n     * @param _metadata Batch metadata (origin, harvest date, etc.)\n     * @param _amount Number of tokens to mint for this batch\n     * @param _merkleRoot Root hash of the Merkle Tree containing all secret keys\n     *\n     * The Merkle Tree allows gas-efficient verification of secret keys during claims.\n     * Each token in the batch corresponds to one secret key in the tree.\n     *\n     * Requirements:\n     * - Caller must be an authorized producer\n     * - Producer must have called setApprovalForAll on HoneyTokenization\n     *\n     * Emits a {NewHoneyBatch} event\n     */\n    function addHoneyBatch(\n        string memory _honeyType,\n        string memory _metadata,\n        uint256 _amount,\n        bytes32 _merkleRoot\n    ) external onlyAuthorizedProducer {\n        if (bytes(_honeyType).length == 0 || bytes(_honeyType).length > 64) revert InvalidStringLength();\n        if (bytes(_metadata).length == 0 || bytes(_metadata).length > 1024) revert InvalidStringLength();\n        require(_amount <= MAX_BATCH_SIZE, batchSizeTooLarge());\n\n        uint tokenId = honeyTokenization.mintHoneyBatch(\n            msg.sender,\n            _amount,\n            _metadata\n        );\n\n        HoneyBatch storage honeyBatch = honeyBatches[tokenId];\n        honeyBatch.id = tokenId;\n        honeyBatch.honeyType = _honeyType;\n        honeyBatch.metadata = _metadata;\n        honeyBatch.merkleRoot = _merkleRoot;\n\n        emit NewHoneyBatch(msg.sender, tokenId);\n    }\n\n    // ============ CONSUMER FUNCTIONS ============\n\n    /**\n     * @dev Allows a consumer to claim a honey token using a secret key and Merkle proof\n     * @param _honeyBatchId ID of the batch to claim from\n     * @param _secretKey Secret key from the QR code\n     * @param _merkleProof Array of hashes proving the key belongs to the Merkle Tree\n     *\n     * The function performs three security checks:\n     * 1. Verifies tokens are still available (balanceOf > 0)\n     * 2. Verifies the secret key hasn't been used before\n     * 3. Verifies the Merkle proof is valid\n     *\n     * Requirements:\n     * - Batch must have tokens remaining\n     * - Secret key must not have been claimed before\n     * - Merkle proof must be valid\n     * - Producer must have approved HoneyTraceStorage via setApprovalForAll\n     *\n     * Emits a {HoneyTokenClaimed} event\n     */\n    function claimHoneyToken(\n        uint256 _honeyBatchId,\n        string memory _secretKey,\n        bytes32[] memory _merkleProof\n    ) external nonReentrant {\n        HoneyBatch storage batch = honeyBatches[_honeyBatchId];\n        address producer = honeyTokenization.tokenProducer(_honeyBatchId);\n\n        // Check 1: Verify tokens are available\n        uint256 remainingTokens = honeyTokenization.balanceOf(producer, _honeyBatchId);\n        require(remainingTokens > 0, noTokenLeft());\n\n        // Check 2: Verify key hasn't been used\n        bytes32 leaf = keccak256(abi.encodePacked(_secretKey));\n        require(!claimedKeys[_honeyBatchId][leaf], keyAlreadyClaimed());\n\n        // Check 3: Verify Merkle proof\n        require(MerkleProof.verify(_merkleProof, batch.merkleRoot, leaf), invalidMerkleProof());\n\n        // Mark key as claimed\n        claimedKeys[_honeyBatchId][leaf] = true;\n\n        emit HoneyTokenClaimed(msg.sender, _honeyBatchId, leaf);\n\n        // Transfer token from producer to consumer\n        honeyTokenization.safeTransferFrom(producer, msg.sender, _honeyBatchId, 1, \"\");\n\n    }\n\n    /**\n     * @dev Allows a token holder to add a comment/review for a batch\n     * @param _honeyBatchId ID of the batch to comment on\n     * @param _rating Numerical rating (0-5)\n     * @param _metadata Comment text and additional info in JSON format\n     *\n     * Requirements:\n     * - Caller must own at least one token of the specified batch\n     *\n     * Emits a {NewComment} event\n     */\n    function addComment(\n        uint _honeyBatchId,\n        uint8 _rating,\n        string memory _metadata\n    ) external {\n        require(honeyTokenization.balanceOf(msg.sender, _honeyBatchId) > 0, notAllowedToComment());\n        require(_rating <= 5, ratingMustBeBetween0And5());\n        require(commentCount[_honeyBatchId][msg.sender] < MAX_COMMENTS_PER_USER, commentLimitReached());\n        if (bytes(_metadata).length < 5 || bytes(_metadata).length > 500) revert InvalidStringLength();\n\n        honeyBatchesComments[_honeyBatchId].push(\n            Comment(msg.sender, _honeyBatchId, _rating, _metadata)\n        );\n\n        commentCount[_honeyBatchId][msg.sender]++;\n\n        emit NewComment(msg.sender, _honeyBatchId, _rating);\n    }\n\n    // ============ VIEW FUNCTIONS ============\n\n    /**\n     * @dev Returns the information of a producer\n     * @param _address Address of the producer to query\n     * @return Producer struct containing all producer information\n     */\n    function getProducer(address _address) external view returns (Producer memory) {\n        return producers[_address];\n    }\n\n    /**\n     * @dev Returns the information of a honey batch\n     * @param _id ID of the batch to query\n     * @return HoneyBatch struct containing all batch information\n     */\n    function getHoneyBatch(uint _id) external view returns (HoneyBatch memory) {\n        return honeyBatches[_id];\n    }\n\n    /**\n     * @dev Returns all comments for a specific batch (paginated)\n     * @param _honeyBatchId ID of the batch\n     * @param offset Starting index for pagination\n     * @param limit Maximum number of comments to return\n     */\n    function getHoneyBatchComments(\n        uint _honeyBatchId,\n        uint offset,\n        uint limit\n    ) external view returns (Comment[] memory) {\n        uint total = honeyBatchesComments[_honeyBatchId].length;\n\n        if (offset >= total) {\n            return new Comment[](0);\n        }\n\n        uint end = offset + limit > total ? total : offset + limit;\n        uint resultLength = end - offset;\n\n        Comment[] memory result = new Comment[](resultLength);\n        for (uint i = 0; i < resultLength; i++) {\n            result[i] = honeyBatchesComments[_honeyBatchId][offset + i];\n        }\n\n        return result;\n    }\n\n    /**\n    * @dev Returns the total number of comments for a batch\n     */\n    function getHoneyBatchCommentsCount(uint _honeyBatchId) external view returns (uint) {\n        return honeyBatchesComments[_honeyBatchId].length;\n    }\n\n    /**\n     * @dev Checks if a secret key has already been claimed for a batch\n     * @param _honeyBatchId ID of the batch\n     * @param _secretKey Secret key to check\n     * @return True if the key has been claimed, false otherwise\n     */\n    function isKeyClaimed(uint256 _honeyBatchId, string memory _secretKey) external view returns (bool) {\n        bytes32 leaf = keccak256(abi.encodePacked(_secretKey));\n        return claimedKeys[_honeyBatchId][leaf];\n    }\n\n    /**\n     * @dev Checks if an address has admin privileges\n     * @param _address Address to check\n     * @return True if the address is an admin, false otherwise\n     */\n    function isAdmin(address _address) external view returns (bool) {\n        return admins[_address];\n    }\n}"
      }
    }
  }
}